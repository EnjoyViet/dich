<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>다국어 AI 통역기 (3개 언어)</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f7f7; /* 배경색을 살짝 회색으로 변경 */
        }
        /* 마이크/다시듣기 버튼 공통 스타일링 */
        .mic-btn, .replay-btn {
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.06);
        }
        .mic-btn:hover:not(:disabled), .replay-btn:hover:not(:disabled) {
            box-shadow: 0 10px 15px -3px rgba(59, 130, 246, 0.3), 0 4px 6px -4px rgba(59, 130, 246, 0.3);
            transform: translateY(-2px);
        }
        .mic-btn:disabled, .replay-btn:disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }
        /* 녹음 중 스타일 (Mic only) */
        .listening {
            animation: pulse-ring 1s infinite;
        }
        @keyframes pulse-ring {
            0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            70% { box-shadow: 0 0 0 15px rgba(239, 68, 68, 0); }
            100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
        }
    </style>
</head>
<body class="min-h-screen flex items-start justify-center p-0">

    <!-- 통역 세션 영역 -->
    <div class="w-full h-screen bg-white p-4 md:p-6 overflow-y-auto max-w-lg shadow-lg"> 
        <h1 class="text-2xl font-extrabold text-gray-800 mb-6 text-center">다국어 실시간 통역</h1>

        <!-- 언어 선택 영역 -->
        <div class="flex space-x-4 mb-6 p-4 bg-gray-100 rounded-xl border border-gray-200">
            <!-- My Language Selector (L1) -->
            <div class="flex-1">
                <label for="selectL1" class="block text-sm font-medium text-gray-700">나의 언어 (My Language)</label>
                <select id="selectL1" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md bg-white">
                    <option value="ko-KR">한국어 (Korean)</option>
                    <option value="en-US">영어 (English)</option>
                    <option value="vi-VN">베트남어 (Vietnamese)</option>
                </select>
            </div>
            <!-- Their Language Selector (L2) -->
            <div class="flex-1">
                <label for="selectL2" class="block text-sm font-medium text-gray-700">상대방 언어 (Their Language)</label>
                <select id="selectL2" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md bg-white">
                    <option value="vi-VN">베트남어 (Vietnamese)</option>
                    <option value="en-US">영어 (English)</option>
                    <option value="ko-KR">한국어 (Korean)</option>
                </select>
            </div>
        </div>

        <!-- 나의 언어 (My Language) 섹션: L1 -->
        <div id="sectionL1" class="bg-blue-50 border-2 border-blue-200 rounded-xl p-4 mb-6">
            <div class="flex justify-between items-center mb-4">
                <h2 id="titleL1" class="text-xl font-bold text-blue-700"></h2>
                <span id="speakerL1" class="text-sm text-blue-500 font-semibold"></span>
            </div>
            <div id="outputL1" class="min-h-[6rem] p-3 bg-white rounded-lg border border-blue-200 text-gray-700 break-words text-base">
                번역된 상대방 언어 음성 출력이 여기에 표시됩니다.
            </div>
            <div class="flex justify-center mt-4 space-x-4">
                <!-- 마이크 버튼 -->
                <button id="micL1" onclick="startRecognition('L1')"
                        class="mic-btn bg-blue-500 text-white p-4 rounded-full w-20 h-20 flex items-center justify-center disabled:bg-gray-400">
                    <!-- Mic Icon -->
                    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" viewBox="0 0 256 256"><path d="M128,176a48,48,0,0,0,48-48V64a48,48,0,0,0-96,0v64A48,48,0,0,0,128,176ZM184,128a56,56,0,0,1-112,0V64a56,56,0,0,1,112,0Z" opacity="0.2"/><path d="M128,216a7.9,7.9,0,0,1-8-8V192a8,8,0,0,1,16,0v16A7.9,7.9,0,0,1,128,216ZM200,128a72,72,0,0,0-144,0v40a8,8,0,0,0,16,0V128a56,56,0,0,1,112,0v40a8,8,0,0,0,16,0ZM128,184a48,48,0,0,0,48-48V64a48,48,0,0,0-96,0v72A48,48,0,0,0,128,184Zm-40-56a40,40,0,0,1,80,0V64a40,40,0,0,1-80,0Zm-8,88a80.1,80.1,0,0,0,152,0a8,8,0,0,0-16,0a64,64,0,0,1-128,0a8,8,0,0,0-16,0Z"/></svg>
                </button>
                
                <!-- 다시 듣기 버튼 (Replay L1 Output) -->
                <button id="replayL1" onclick="replayLastText('L1')" disabled
                        class="replay-btn bg-gray-400 text-white p-4 rounded-full w-20 h-20 flex flex-col items-center justify-center text-xs disabled:bg-gray-400">
                    <!-- Replay Icon -->
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 256 256"><path d="M128,40a88.1,88.1,0,0,0-72,142.45L40,168a8,8,0,0,0-13.6,5.66l16,32a8,8,0,0,0,7.6,4.34h.34a8,8,0,0,0,7.26-4.66l16-32A8,8,0,0,0,72,168l-16,14.45A72,72,0,1,1,128,200a8,8,0,0,0,0,16A88,88,0,1,0,128,40Z"/></svg>
                    다시 듣기
                </button>
            </div>
        </div>

        <!-- 상대방 언어 (Their Language) 섹션: L2 -->
        <div id="sectionL2" class="bg-red-50 border-2 border-red-200 rounded-xl p-4">
            <div class="flex justify-between items-center mb-4">
                <h2 id="titleL2" class="text-xl font-bold text-red-700"></h2>
                <span id="speakerL2" class="text-sm text-red-500 font-semibold"></span>
            </div>
            <div id="outputL2" class="min-h-[6rem] p-3 bg-white rounded-lg border border-red-200 text-gray-700 break-words text-base">
                번역된 나의 언어 음성 출력이 여기에 표시됩니다.
            </div>
            <div class="flex justify-center mt-4 space-x-4">
                <!-- 마이크 버튼 -->
                <button id="micL2" onclick="startRecognition('L2')" 
                        class="mic-btn bg-red-500 text-white p-4 rounded-full w-20 h-20 flex items-center justify-center disabled:bg-gray-400">
                    <!-- Mic Icon -->
                    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" viewBox="0 0 256 256"><path d="M128,176a48,48,0,0,0,48-48V64a48,48,0,0,0-96,0v64A48,48,0,0,0,128,176ZM184,128a56,56,0,0,1-112,0V64a56,56,0,0,1,112,0Z" opacity="0.2"/><path d="M128,216a7.9,7.9,0,0,1-8-8V192a8,8,0,0,1,16,0v16A7.9,7.9,0,0,1,128,216ZM200,128a72,72,0,0,0-144,0v40a8,8,0,0,0,16,0V128a56,56,0,0,1,112,0v40a8,8,0,0,0,16,0ZM128,184a48,48,0,0,0,48-48V64a48,48,0,0,0-96,0v72A48,48,0,0,0,128,184Zm-40-56a40,40,0,0,1,80,0V64a40,40,0,0,1-80,0Zm-8,88a80.1,80.1,0,0,0,152,0a8,8,0,0,0-16,0a64,64,0,0,1-128,0a8,8,0,0,0-16,0Z"/></svg>
                </button>
                
                <!-- 다시 듣기 버튼 (Replay L2 Output) -->
                <button id="replayL2" onclick="replayLastText('L2')" disabled
                        class="replay-btn bg-gray-400 text-white p-4 rounded-full w-20 h-20 flex flex-col items-center justify-center text-xs disabled:bg-gray-400">
                    <!-- Replay Icon -->
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 256 256"><path d="M128,40a88.1,88.1,0,0,0-72,142.45L40,168a8,8,0,0,0-13.6,5.66l16,32a8,8,0,0,0,7.6,4.34h.34a8,8,0,0,0,7.26-4.66l16-32A8,8,0,0,0,72,168l-16,14.45A72,72,0,1,1,128,200a8,8,0,0,0,0,16A88,88,0,1,0,128,40Z"/></svg>
                    다시 듣기
                </button>
            </div>
        </div>
        
        <!-- 대화 기록 영역 -->
        <div class="mt-8 pt-4 border-t border-gray-200">
            <h3 class="text-lg font-bold text-gray-700 mb-3">대화 기록</h3>
            <div id="chatHistory" class="max-h-48 overflow-y-auto p-3 bg-gray-50 rounded-lg text-sm text-gray-600">
                <!-- 대화 메시지가 여기에 표시됩니다 -->
            </div>
        </div>

    </div>

    <script>
        // ===================================================================
        // 1. 설정 및 상태 변수
        // ===================================================================
        const API_KEY = ""; 
        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${API_KEY}`;
        const MODEL = 'gemini-2.5-flash-preview-09-2025';

        let conversationHistory = [];
        let isSpeaking = false;
        let isTranslating = false;
        let activeRecognition = null; // 활성 SpeechRecognition 인스턴스를 저장하여 중지 요청 처리
        
        // 마지막 번역 결과를 저장하여 '다시 듣기' 기능에 사용
        let lastL1Translation = ''; // L2 입력 -> L1 출력 (나의 언어 번역 결과)
        let lastL2Translation = ''; // L1 입력 -> L2 출력 (상대방 언어 번역 결과)

        // 언어 코드 및 이름 매핑
        const LANG_MAP = {
            'ko-KR': '한국어 (Korean)',
            'en-US': '영어 (English)',
            'vi-VN': '베트남어 (Vietnamese)'
        };

        let selectedL1Code = 'ko-KR'; // 나의 언어 (기본: 한국어)
        let selectedL2Code = 'vi-VN'; // 상대방 언어 (기본: 베트남어)

        const elements = {
            selectL1: document.getElementById('selectL1'),
            selectL2: document.getElementById('selectL2'),
            
            // L1 (나의 언어) 요소
            titleL1: document.getElementById('titleL1'),
            speakerL1: document.getElementById('speakerL1'),
            outputL1: document.getElementById('outputL1'),
            micL1: document.getElementById('micL1'),
            replayL1: document.getElementById('replayL1'), // 추가
            
            // L2 (상대방 언어) 요소
            titleL2: document.getElementById('titleL2'),
            speakerL2: document.getElementById('speakerL2'),
            outputL2: document.getElementById('outputL2'),
            micL2: document.getElementById('micL2'),
            replayL2: document.getElementById('replayL2'), // 추가

            chatHistory: document.getElementById('chatHistory'),
        };
        
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) {
            console.error('🔴 오류: 이 브라우저는 Speech Recognition을 지원하지 않습니다.');
        }

        // ===================================================================
        // 2. UI 및 상태 관리 함수
        // ===================================================================

        /**
         * 언어 선택에 따라 UI 텍스트를 업데이트합니다.
         */
        function updateUI() {
            const L1_NAME = LANG_MAP[selectedL1Code];
            const L2_NAME = LANG_MAP[selectedL2Code];

            // L1 UI 업데이트
            elements.titleL1.textContent = L1_NAME;
            elements.speakerL1.textContent = `🎙️ ${L1_NAME} 화자`;
            if(elements.outputL1.textContent.includes('번역된 상대방 언어')) {
                elements.outputL1.textContent = `${L2_NAME}로 번역된 음성 출력이 여기에 표시됩니다.`;
            }

            // L2 UI 업데이트
            elements.titleL2.textContent = L2_NAME;
            elements.speakerL2.textContent = `🎙️ ${L2_NAME} 화자`;
            if(elements.outputL2.textContent.includes('번역된 나의 언어')) {
                elements.outputL2.textContent = `${L1_NAME}로 번역된 음성 출력이 여기에 표시됩니다.`;
            }
            
            // 언어 선택이 같을 경우 경고 (선택 UI에만 적용)
            if (selectedL1Code === selectedL2Code) {
                 elements.selectL2.classList.add('border-red-500', 'ring-red-500');
                 elements.selectL1.classList.add('border-red-500', 'ring-red-500');
                 updateStatus('⚠️ 나의 언어와 상대방 언어가 같습니다. 다른 언어를 선택해주세요.', 'warning');
                 elements.micL1.disabled = true;
                 elements.micL2.disabled = true;
            } else {
                 elements.selectL2.classList.remove('border-red-500', 'ring-red-500');
                 elements.selectL1.classList.remove('border-red-500', 'ring-red-500');
                 elements.micL1.disabled = false;
                 elements.micL2.disabled = false;
            }
        }

        /**
         * 상태 메시지를 업데이트합니다. (화면에는 표시하지 않고 콘솔에만 기록)
         */
        function updateStatus(message, type = 'info') {
            console.log(`[Status - ${type.toUpperCase()}] ${message}`);
        }

        /**
         * 마이크/다시듣기 버튼의 활성화/비활성화 상태와 스타일을 업데이트합니다.
         * @param {string|null} listeningSource - 현재 듣고 있는 마이크 ('L1' or 'L2') 또는 null (준비 상태)
         */
        function updateMicButtons(listeningSource = null) {
            elements.micL1.classList.remove('listening');
            elements.micL2.classList.remove('listening');
            
            // --- Replay Button Logic ---
            // Replay 버튼은 현재 음성 출력이 진행 중이지 않을 때 활성화됩니다.
            const canReplay = !isSpeaking;

            // L1 Replay: L2 입력의 번역 결과(L1 언어)를 재생합니다.
            elements.replayL1.disabled = !(canReplay && lastL1Translation);
            elements.replayL1.classList.toggle('bg-green-500', !elements.replayL1.disabled);
            
            // L2 Replay: L1 입력의 번역 결과(L2 언어)를 재생합니다.
            elements.replayL2.disabled = !(canReplay && lastL2Translation);
            elements.replayL2.classList.toggle('bg-red-500', !elements.replayL2.disabled);

            // 비활성화 시 기본 회색 배경 적용
            if (elements.replayL1.disabled) elements.replayL1.classList.remove('bg-green-500');
            if (elements.replayL2.disabled) elements.replayL2.classList.remove('bg-red-500');

            // --- Mic Button Logic ---
            // 0. 언어 선택이 같거나 번역 중일 때 (마이크 비활성화)
            if (selectedL1Code === selectedL2Code || isTranslating) {
                elements.micL1.disabled = true;
                elements.micL2.disabled = true;
                return;
            }

            // 1. 음성 출력 중일 때 (마이크 비활성화)
            if (isSpeaking) {
                elements.micL1.disabled = true;
                elements.micL2.disabled = true;
                return;
            }

            // 2. 음성 인식 중일 때 (listeningSource가 설정되어 있음)
            if (listeningSource) {
                // 활성화된 마이크만 클릭 가능 (중지용), 다른 마이크는 비활성화
                elements.micL1.disabled = (listeningSource !== 'L1');
                elements.micL2.disabled = (listeningSource !== 'L2');
                
                // 시각적 신호
                if (listeningSource === 'L1') {
                    elements.micL1.classList.add('listening');
                    updateStatus(`🎤 ${LANG_MAP[selectedL1Code]} 듣는 중... 녹음 후 버튼을 다시 클릭하여 녹음을 마칩니다.`);
                } else {
                    elements.micL2.classList.add('listening');
                    updateStatus(`🎤 ${LANG_MAP[selectedL2Code]} 듣는 중... 녹음 후 버튼을 다시 클릭하여 녹음을 마칩니다.`);
                }
                return;
            }

            // 3. 준비 상태 (Listening이 끝났거나 초기 상태) - 모두 활성화
            elements.micL1.disabled = false;
            elements.micL2.disabled = false;
            updateStatus('준비 완료. 마이크 버튼을 눌러 통역을 시작하세요.');
        }

        /**
         * 대화 기록을 UI에 추가합니다.
         */
        function appendToChatHistory(role, languageName, text) {
            const time = new Date().toLocaleTimeString();
            const messageDiv = document.createElement('div');
            
            if (role === 'user') {
                messageDiv.className = 'p-2 bg-blue-100 rounded-lg my-2 ml-auto max-w-[90%] text-right shadow-sm';
                messageDiv.innerHTML = `<span class="text-xs text-blue-800 font-semibold">나 (${languageName}, ${time}):</span><br>${text}`;
            } else {
                messageDiv.className = 'p-2 bg-gray-200 rounded-lg my-2 mr-auto max-w-[90%] text-left shadow-sm';
                messageDiv.innerHTML = `<span class="text-xs text-gray-600 font-semibold">Gemini (${languageName}, ${time}):</span><br>${text}`;
            }

            elements.chatHistory.appendChild(messageDiv);
            elements.chatHistory.scrollTop = elements.chatHistory.scrollHeight; // 스크롤 하단으로 이동
        }
        
        /**
         * 언어 선택 변경 핸들러
         */
        function handleLanguageChange() {
            selectedL1Code = elements.selectL1.value;
            selectedL2Code = elements.selectL2.value;
            
            // 언어 변경 시 상태 초기화
            conversationHistory = [];
            lastL1Translation = '';
            lastL2Translation = '';
            elements.chatHistory.innerHTML = '';
            
            updateUI();
            updateMicButtons(null);
        }

        // ===================================================================
        // 3. Speech Recognition (STT) - 음성 입력 처리
        // ===================================================================

        function startRecognition(micSource) {
            if (isTranslating || isSpeaking || !SpeechRecognition) return;

            // --- PUSH-TO-STOP 로직 ---
            if (activeRecognition) {
                // 이미 녹음 중일 때 같은 마이크 버튼을 클릭하면 녹음 종료
                activeRecognition.stop(); 
                activeRecognition = null; // stop 요청 후 바로 null로 설정
                return;
            }
            // --------------------------
            
            let sourceLangCode, targetLangCode, sourceName, targetName, sourceOutputElement;

            if (micSource === 'L1') {
                sourceLangCode = selectedL1Code;
                targetLangCode = selectedL2Code;
                sourceOutputElement = elements.outputL1;
            } else { // micSource === 'L2'
                sourceLangCode = selectedL2Code;
                targetLangCode = selectedL1Code;
                sourceOutputElement = elements.outputL2;
            }
            
            sourceName = LANG_MAP[sourceLangCode];
            targetName = LANG_MAP[targetLangCode];

            // 언어 선택이 같은 경우 방지
            if (sourceLangCode === targetLangCode) return;


            const recognition = new SpeechRecognition();
            activeRecognition = recognition; // 활성 인스턴스 저장

            recognition.lang = sourceLangCode;
            recognition.interimResults = false;
            recognition.maxAlternatives = 1;

            // UI 업데이트 - 현재 마이크만 활성화 (중지 클릭용)
            updateMicButtons(micSource);

            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                updateStatus(`🔍 ${sourceName} 음성 입력 인식 완료. 번역 중...`);
                
                // UI에 입력 텍스트 표시
                sourceOutputElement.textContent = transcript;
                
                appendToChatHistory('user', sourceName, transcript);

                // 번역 및 음성 출력 시작 (지연 최소화)
                translateAndSpeak(transcript, sourceLangCode, targetLangCode, targetName, micSource);
                // onresult가 발생하면 onend에서 activeRecognition을 null로 설정하지 않음.
                activeRecognition = null; 
            };

            recognition.onerror = (event) => {
                const msg = `🔴 음성 인식 오류: ${event.error}`;
                updateStatus(msg, 'error');
                console.error(msg);
                
                activeRecognition = null; 
                updateMicButtons(null); 
            };

            recognition.onend = () => {
                // onresult에서 이미 통역을 시작했거나, 수동으로 중지했으므로, 
                // activeRecognition이 남아있는 경우는 무음 등으로 인한 자동 종료 뿐임.
                if (activeRecognition) {
                    activeRecognition = null;
                    updateStatus('⚠️ 음성 입력이 인식되지 않았습니다. 다시 시도해 주세요.', 'error');
                    updateMicButtons(null); 
                }
            };

            recognition.start();
        }

        // ===================================================================
        // 4. Text-to-Speech (TTS) - 음성 출력 처리
        // ===================================================================

        // TTS가 모든 브라우저에서 올바르게 초기화되도록 voiceschanged 이벤트 사용
        window.speechSynthesis.onvoiceschanged = () => {
             // TTS 목소리 목록이 로드된 후에도 updateMicButtons 호출은 필요 없음
        };

        function speakText(text, langCode) {
            if (isSpeaking) {
                window.speechSynthesis.cancel();
            }
            
            isSpeaking = true;
            updateMicButtons(null); // 음성 출력 중에는 마이크 버튼 비활성화

            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = langCode;
            
            const voices = window.speechSynthesis.getVoices();
            // TTS 언어 코드는 보통 'ko-KR'과 같이 지역 코드까지 포함되므로 startsWith 사용
            const voice = voices.find(v => v.lang.startsWith(langCode.substring(0, 2))); 
            if (voice) {
                utterance.voice = voice;
            } 

            utterance.onstart = () => {
                updateStatus(`🔊 ${LANG_MAP[langCode]} 음성 출력 중...`);
            };

            utterance.onend = () => {
                isSpeaking = false;
                // TTS 완료 후, 모든 컨트롤 활성화 (updateMicButtons 내부에서 Replay 버튼 상태도 재계산됨)
                updateMicButtons(null); 
            };

            utterance.onerror = (event) => {
                const msg = `🔴 음성 출력 오류: ${event.error}`;
                updateStatus(msg, 'error');
                console.error(msg);
                isSpeaking = false;
                updateMicButtons(null); 
            };

            window.speechSynthesis.speak(utterance);
        }
        
        /**
         * '다시 듣기' 버튼 클릭 시 마지막 번역된 텍스트를 재생합니다.
         * @param {string} side - 'L1' (나의 언어 출력) 또는 'L2' (상대방 언어 출력)
         */
        function replayLastText(side) {
            if (isTranslating || isSpeaking) return;

            let textToSpeak = '';
            let langCode = '';

            if (side === 'L1') { // L1 Output (나의 언어로 번역된 텍스트)
                textToSpeak = lastL1Translation;
                langCode = selectedL1Code;
            } else { // L2 Output (상대방 언어로 번역된 텍스트)
                textToSpeak = lastL2Translation;
                langCode = selectedL2Code;
            }

            if (textToSpeak) {
                updateStatus(`🔄 ${LANG_MAP[langCode]} 이전 텍스트 다시 듣기 요청`);
                speakText(textToSpeak, langCode);
            } else {
                updateStatus('⚠️ 다시 들을 텍스트가 없습니다. 먼저 통역을 시도해 주세요.', 'warning');
            }
        }


        // ===================================================================
        // 5. Gemini API 번역 및 컨텍스트 관리 (최대 속도 유지)
        // ===================================================================

        /**
         * 지수 백오프를 사용하여 API 호출을 시도합니다.
         */
        async function withExponentialBackoff(fn, maxRetries = 3) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    return await fn();
                } catch (error) {
                    if (i === maxRetries - 1) {
                        throw error;
                    }
                    const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        async function translateAndSpeak(text_to_translate, sourceLangCode, targetLangCode, targetName, micSource) {
            if (isTranslating) return;

            isTranslating = true;
            updateStatus(`✨ ${targetName}로 전문가 번역 중...`);
            
            // 번역 중에는 모든 마이크 버튼 비활성화
            updateMicButtons(null); 
            
            const sourceName = LANG_MAP[sourceLangCode];
            const targetOutputElement = micSource === 'L1' ? elements.outputL2 : elements.outputL1;

            // 1. 시스템 지침 설정
            const systemPrompt = `You are a professional ${sourceName} to ${targetName} simultaneous interpreter. Translate the user's input into natural, contextually appropriate, and polite ${targetName}. Only output the translated text. Do not include any extra commentary or formatting.`;

            // 2. 대화 기록에 사용자 입력 추가
            const userPart = { role: "user", parts: [{ text: text_to_translate }] };
            conversationHistory.push(userPart);

            // 3. API Payload 구성: 속도 최적화를 위해 최근 4개 턴(2쌍의 대화 + 현재 발화)만 전송
            const contentsForApi = conversationHistory.slice(-4); 

            const payload = {
                contents: contentsForApi, 
                systemInstruction: { parts: [{ text: systemPrompt }] },
                config: { temperature: 0.2 }, 
            };
            
            try {
                const fetcher = async () => {
                    const response = await fetch(API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errorBody = await response.text();
                        throw new Error(`HTTP error! status: ${response.status}. Body: ${errorBody}`);
                    }
                    return response.json();
                };

                const result = await withExponentialBackoff(fetcher);
                const translatedText = result.candidates?.[0]?.content?.parts?.[0]?.text?.trim() || "번역 결과가 없습니다.";

                // 4. 번역 결과 저장
                if (micSource === 'L1') {
                    lastL2Translation = translatedText; // L1 입력 -> L2 출력
                } else {
                    lastL1Translation = translatedText; // L2 입력 -> L1 출력
                }

                // 5. UI 업데이트
                targetOutputElement.textContent = translatedText;

                // 6. 대화 기록에 모델 응답 추가
                const modelPart = { role: "model", parts: [{ text: translatedText }] };
                conversationHistory.push(modelPart);
                appendToChatHistory('model', targetName, translatedText);
                
                // 7. 음성 출력 (지연 없이 즉시 시작)
                speakText(translatedText, targetLangCode);

            } catch (e) {
                console.error("Gemini API Error:", e);
                const errorMsg = `🔴 번역 실패: API 통신 중 오류가 발생했습니다. (자세한 내용은 콘솔 확인)`;
                updateStatus(errorMsg, 'error');
                
                // 오류 발생 시 마이크 버튼 다시 활성화
                updateMicButtons(null);
            } finally {
                isTranslating = false;
            }
        }

        // ===================================================================
        // 6. 초기화 및 이벤트 리스너
        // ===================================================================

        window.onload = () => {
            // 초기 UI 설정
            updateUI(); 

            if (SpeechRecognition) {
                // 초기 상태: 양쪽 마이크 및 다시듣기 버튼 상태 업데이트
                updateMicButtons(null); 
            }
            
            // 언어 선택 변경 이벤트 리스너
            elements.selectL1.addEventListener('change', handleLanguageChange);
            elements.selectL2.addEventListener('change', handleLanguageChange);
        };
    </script>
</body>
</html>
